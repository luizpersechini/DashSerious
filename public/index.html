<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Commodities Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/styles.css" />
    <script src="/lib/lightweight-charts/lightweight-charts.standalone.production.js"></script>
  </head>
  <body>
    <div class="appbar">
      <div class="brand">Commodities Dashboard</div>
      <div style="margin-left:auto; display:flex; align-items:center; gap:12px;">
        <button id="refreshBtn" class="refresh-btn" title="Refresh data from API">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M2 2v4h4M14 14v-4h-4M2.5 9A6 6 0 0 1 14 6M13.5 7A6 6 0 0 1 2 10"/>
          </svg>
          Refresh
        </button>
        <span class="badge">Last update: <span id="lastUpdated">—</span></span>
      </div>
    </div>
    <main class="container">
      <div id="cards"></div>
    </main>

    <script>
      const METALS = [
        { name: 'Gold', key: 'gold', symbol: 'XAU' },
        { name: 'Silver', key: 'silver', symbol: 'XAG' },
        { name: 'Platinum', key: 'platinum', symbol: 'XPT' },
        { name: 'Palladium', key: 'palladium', symbol: 'XPD' },
        { name: 'Copper', key: 'copper', symbol: 'XCU' },
        { name: 'Nickel', key: 'nickel', symbol: 'NI' },
        { name: 'Cobalt', key: 'cobalt', symbol: 'XCO' },
        { name: 'USD/BRL', key: 'brl', symbol: 'BRL' },
      ];

      function createCard(el, title, metalKey) {
        const div = document.createElement('div');
        const classMap = {
          gold: 'metal-gold', silver: 'metal-silver', platinum: 'metal-platinum',
          palladium: 'metal-palladium', copper: 'metal-copper', nickel: 'metal-nickel', cobalt: 'metal-cobalt'
        };
        div.className = `card ${classMap[metalKey] || ''}`;
        div.dataset.metal = metalKey; // Store metal key for unique gradient IDs
        div.innerHTML = `
          <div class="title">${title}</div>
          <div class="value price">—</div>
          <div class="controls">
            <label class="muted" style="margin-right:auto">Chart</label>
            <select class="tf">
              <option value="30">30d</option>
              <option value="90">90d</option>
              <option value="180">180d</option>
              <option value="360" selected>1yr</option>
            </select>
            <select class="per">
              <option value="daily" selected>Daily</option>
              <option value="weekly">Weekly</option>
              <option value="monthly">Monthly</option>
            </select>
          </div>
          <div class="chart-container"></div>
        `;
        // Make all cards clickable
        div.style.cursor = 'pointer';
        div.addEventListener('click', function(e) {
          // avoid navigation when interacting with controls
          var t = e.target;
          var tag = (t && t.tagName ? String(t.tagName).toLowerCase() : '');
          var inControls = t && typeof t.closest === 'function' ? t.closest('.controls') : null;
          if (tag === 'select' || tag === 'option' || inControls) return;
          window.location.href = '/' + metalKey + '.html';
        });
        el.appendChild(div);
        return div;
      }

      async function loadMetal(key, card) {
        const res = await fetch(`/api/${key}/latest`);
        const data = await res.json();
        if (!data.success) return;
        const d = data.data;
        const priceEl = card.querySelector('.price');
        const nf2 = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 2 });
        const nf4 = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 4 });
        const nf0 = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 });
        if (key === 'brl') {
          const fx = d.fxUsdBrl ?? 0;
          const fxFmt = new Intl.NumberFormat('en-US', { minimumFractionDigits: 4, maximumFractionDigits: 4 });
          priceEl.innerHTML = `${fxFmt.format(fx)} <span class="unit">USD/BRL</span>`;
        } else if (key === 'copper' || key === 'nickel') {
          priceEl.innerHTML = `${nf4.format(d.usdPerPound ?? 0)} <span class="unit">USD/lb</span>`;
        } else if (key === 'cobalt') {
          priceEl.innerHTML = `${nf0.format(d.usdPerMetricTon ?? 0)} <span class="unit">USD/ton</span>`;
        } else {
          priceEl.innerHTML = `${nf2.format(d.usdPerOunce)} <span class="unit">USD/oz</span>`;
        }
        const dt = new Date(d.timestamp);
        const top = document.getElementById('lastUpdated');
        if (top) top.textContent = dt.toLocaleString();

        await refreshChart(key, card);
      }

      let cards = [];

      // Wait for LightweightCharts to load, then initialize
      function init() {
        if (typeof LightweightCharts === 'undefined') {
          console.log('Waiting for LightweightCharts to load...');
          setTimeout(init, 100);
          return;
        }

        const container = document.getElementById('cards');
        METALS.forEach(m => {
          const card = createCard(container, `${m.name} (${m.symbol})`, m.key);
          cards.push({ key: m.key, card });
          loadMetal(m.key, card).catch(err => {
            card.querySelector('.updated').textContent = String(err);
          });
          // Wire up controls to update chart on change
          const tfSel = card.querySelector('.tf');
          const perSel = card.querySelector('.per');
          if (tfSel) tfSel.addEventListener('change', () => refreshChart(m.key, card));
          if (perSel) perSel.addEventListener('change', () => refreshChart(m.key, card));
        });

        // Wire up refresh button
        const refreshBtn = document.getElementById('refreshBtn');
        if (refreshBtn) {
          refreshBtn.addEventListener('click', async () => {
            refreshBtn.disabled = true;
            refreshBtn.classList.add('spinning');
            try {
              // Call the refresh API endpoint
              const res = await fetch('/api/refresh', { method: 'POST' });
              const data = await res.json();
              if (data.success) {
                // Reload all metal data
                for (const { key, card } of cards) {
                  await loadMetal(key, card).catch(() => {});
                }
              }
            } catch (err) {
              console.error('Refresh failed:', err);
            } finally {
              refreshBtn.disabled = false;
              refreshBtn.classList.remove('spinning');
            }
          });
        }
      }

      // Start initialization when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }

      async function refreshChart(key, card) {
        const days = Number(card.querySelector('.tf').value) || 360;
        const periodicity = String(card.querySelector('.per')?.value || 'daily');
        try {
          const ts = await fetch(`/api/${key}/timeseries?limit=${days + 5}`).then(r => r.json());
          if (ts.success) {
            let points = ts.data.points;
            // Ensure ascending by time
            points = points.sort((a, b) => a.t - b.t);
            // Cut to last N days
            points = points.slice(-days);
            if (periodicity === 'weekly') points = aggregateWeekly(points);
            else if (periodicity === 'monthly') points = aggregateMonthly(points);
            renderChart(card.querySelector('.chart-container'), points, key);
          }
        } catch (e) { /* ignore */ }
      }
      function startOfDay(ts) { const d = new Date(ts); d.setHours(0,0,0,0); return d.getTime(); }
      function startOfWeek(ts) {
        const d = new Date(startOfDay(ts));
        const day = d.getDay(); // 0=Sun
        const diff = (day + 6) % 7; // make Monday start
        d.setDate(d.getDate() - diff);
        return d.getTime();
      }
      function startOfMonth(ts) { const d = new Date(startOfDay(ts)); d.setDate(1); return d.getTime(); }
      function aggregateWeekly(points) {
        const map = new Map();
        for (const p of points) {
          const k = startOfWeek(p.t);
          const arr = map.get(k) || []; arr.push(p.v); map.set(k, arr);
        }
        const out = [];
        for (const [k, arr] of Array.from(map.entries()).sort((a,b)=>a[0]-b[0])) {
          const avg = arr.reduce((s,x)=>s+x,0)/arr.length;
          out.push({ t: Number(k), v: avg });
        }
        return out;
      }
      function aggregateMonthly(points) {
        const map = new Map();
        for (const p of points) {
          const k = startOfMonth(p.t);
          const arr = map.get(k) || []; arr.push(p.v); map.set(k, arr);
        }
        const out = [];
        for (const [k, arr] of Array.from(map.entries()).sort((a,b)=>a[0]-b[0])) {
          const avg = arr.reduce((s,x)=>s+x,0)/arr.length;
          out.push({ t: Number(k), v: avg });
        }
        return out;
      }
      // Store chart instances for cleanup
      const chartInstances = new Map();

      // Get metal-specific colors from CSS
      function getMetalColors(metalKey) {
        const colorMap = {
          gold: { line: '#fbbf24', top: 'rgba(251, 191, 36, 0.4)', bottom: 'rgba(251, 191, 36, 0.0)' },
          silver: { line: '#cbd5e1', top: 'rgba(203, 213, 225, 0.4)', bottom: 'rgba(203, 213, 225, 0.0)' },
          platinum: { line: '#d4d4d8', top: 'rgba(212, 212, 216, 0.4)', bottom: 'rgba(212, 212, 216, 0.0)' },
          palladium: { line: '#22d3ee', top: 'rgba(34, 211, 238, 0.4)', bottom: 'rgba(34, 211, 238, 0.0)' },
          copper: { line: '#fb923c', top: 'rgba(251, 146, 60, 0.4)', bottom: 'rgba(251, 146, 60, 0.0)' },
          nickel: { line: '#34d399', top: 'rgba(52, 211, 153, 0.4)', bottom: 'rgba(52, 211, 153, 0.0)' },
          cobalt: { line: '#60a5fa', top: 'rgba(96, 165, 250, 0.4)', bottom: 'rgba(96, 165, 250, 0.0)' },
          brl: { line: '#22d3ee', top: 'rgba(34, 211, 238, 0.4)', bottom: 'rgba(34, 211, 238, 0.0)' }
        };
        return colorMap[metalKey] || colorMap.gold;
      }

      function renderChart(container, points, metalKey) {
        if (!points || points.length < 2) {
          container.innerHTML = '<div style="text-align:center;padding:20px;color:#94a3b8;">No data</div>';
          return;
        }

        // Check if Lightweight Charts is loaded
        if (typeof LightweightCharts === 'undefined') {
          console.error('LightweightCharts library not loaded');
          container.innerHTML = '<div style="text-align:center;padding:20px;color:#94a3b8;">Loading chart library...</div>';
          return;
        }
        
        // Debug: log available methods
        console.log('LightweightCharts object:', LightweightCharts);
        console.log('LightweightCharts.createChart:', typeof LightweightCharts.createChart);

        // Clear existing chart
        const existingChart = chartInstances.get(container);
        if (existingChart) {
          try {
            existingChart.remove();
          } catch (e) {
            console.warn('Error removing old chart:', e);
          }
        }
        container.innerHTML = '';

        try {
          // Ensure container has dimensions
          if (container.clientWidth === 0 || container.clientHeight === 0) {
            console.warn('Container has no dimensions, waiting...');
            setTimeout(() => renderChart(container, points, metalKey), 100);
            return;
          }

          // Create chart with v4 API - dark theme matching dashboard
          const colors = getMetalColors(metalKey);
          
          const chart = LightweightCharts.createChart(container, {
            width: container.clientWidth,
            height: 140,
            layout: {
              background: { type: 'solid', color: 'transparent' },
              textColor: '#94a3b8',
              fontSize: 11,
              fontFamily: 'Inter, system-ui, -apple-system, sans-serif',
            },
            grid: {
              vertLines: { 
                visible: false 
              },
              horzLines: { 
                color: '#1f2937',
                style: 0,
                visible: true 
              },
            },
            crosshair: {
              mode: LightweightCharts.CrosshairMode.Normal,
              vertLine: {
                color: '#94a3b8',
                width: 1,
                style: 3,
                labelBackgroundColor: '#1f2937',
              },
              horzLine: {
                color: '#94a3b8',
                width: 1,
                style: 3,
                labelBackgroundColor: '#1f2937',
              },
            },
            leftPriceScale: {
              visible: true,
              borderVisible: false,
              scaleMargins: {
                top: 0.1,
                bottom: 0.1,
              },
            },
            localization: {
              priceFormatter: (price) => {
                // Remove decimals for values >= 1000, show 2 decimals for smaller values
                if (Math.abs(price) >= 1000) {
                  return new Intl.NumberFormat('en-US', {
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0,
                  }).format(price);
                } else if (Math.abs(price) >= 1) {
                  return new Intl.NumberFormat('en-US', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2,
                  }).format(price);
                } else {
                  return new Intl.NumberFormat('en-US', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 4,
                  }).format(price);
                }
              },
            },
            rightPriceScale: {
              visible: false,
            },
            timeScale: {
              borderVisible: false,
              timeVisible: false,
              secondsVisible: false,
            },
            handleScroll: false,
            handleScale: false,
            watermark: {
              visible: false,
            },
          });

          // v4 API: addAreaSeries
          const series = chart.addAreaSeries({
            lineColor: colors.line,
            topColor: colors.top,
            bottomColor: colors.bottom,
            lineWidth: 2,
            crosshairMarkerVisible: false,
            lastValueVisible: false,
            priceLineVisible: false,
          });

          // Convert data to Lightweight Charts format
          // Lightweight Charts expects time as Unix timestamp (seconds) as a string or number
          const data = points
            .filter(p => p && typeof p.t === 'number' && typeof p.v === 'number' && !isNaN(p.v))
            .map(p => ({
              time: Math.floor(p.t / 1000), // Unix timestamp in seconds
              value: Number(p.v)
            }))
            .sort((a, b) => a.time - b.time);

          console.log('Rendering', data.length, 'points for', metalKey, '- sample:', data.slice(0, 3));

          if (data.length < 2) {
            throw new Error('Not enough valid data points after filtering');
          }

          series.setData(data);
          chart.timeScale().fitContent();

          // Store chart instance
          chartInstances.set(container, chart);

          // Handle resize
          const resizeObserver = new ResizeObserver(() => {
            if (chart && container.clientWidth > 0) {
              chart.applyOptions({ width: container.clientWidth });
            }
          });
          resizeObserver.observe(container);
        } catch (error) {
          console.error('Error rendering chart for', metalKey, ':', error, points);
          container.innerHTML = '<div style="text-align:center;padding:20px;color:#ef4444;">Chart error: ' + error.message + '</div>';
        }
      }
    </script>
  </body>
  </html>


